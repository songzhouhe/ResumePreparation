# How does virtual memory work?
- 运行内存：主存、RAM\(Random Accesss Memory\)、物理内存
- CPU将物理内存中的某段空间作为虚拟内存分配给对应的进程，进程只能通过虚拟内存地址来访问；要通过内存管理单元（Memory Management Unit），将虚拟内存地址转换为对应物理地址，才可以访问到对应的主存内容，即：地址翻译（address translation）
- 虚拟内存地址 -> 内存管理单元 -> 物理内存地址

### 页 Page
- 为了方便管理？物理内存和虚拟内存会按照同样的字节大小分割成页（page），分别叫做虚拟页（Virtual Page）和物理页（Physical Page）
- 其中虚拟页面可能会存于以下3种状态中的其中一种
  - 未分配
    - 该虚拟地址范围还没有被进程正式申请使用
    - 其页表项（Page Table Entry, PTE）可能甚至不存在，如果存在的话，那么该PTE的有效位为0
    - 未分配 -> 已缓存：当进程调用malloc、new或者brk/sbrk等显式申请空间，操作系统就会给虚拟页关联物理页
  - 已缓存/未缓存
    - 已经给该虚拟页分配关联物理页了，如果是"已缓存"的话，对应的内容存放在物理内存的一个页帧中，CPU可以直接、快速地访问该页帧内容
    - PTE中的有效位值为1，且地址字段的值为一个有效的物理内存地址
    - 未缓存 -> 已缓存：操作系统尝试读取该页帧，触发缺页异常，然后操作系统会选择一个物理页，将对应的内容拷贝到该物理页
    - 页命中：当尝试读取某个虚拟页，其状态为"已缓存"，能顺利直接读取到，那就是命中了
  - 未缓存
    - 如果系统内存紧张，操作系统有可能会将某些比较少被访问到的页面换出到交换区（swapping）
    - Question：被置换到交换区的虚拟页面，其PTE中的有效位值会被设置成0吗

### 局部性（locality）
> 在任意时刻，程序将趋向于在一个较小的活动页面（active page）集合上工作，这个集合叫做工作集（working set）或者常驻集合（resident set）

### 虚拟内存作为内存管理的工具
- 简化链接
> 独立的地址空间允许每个进程的内存映像使用相同的基本格式
- 简化加载
- 简化共享
> 操作系统通过将不同进程中适当的虚拟页面映射到相同的物理页面，从而安排多个进程共享这部分代码的一个副本，而不是在每个进程中都包含单独的内核和C标准库的副本
- 简化内存分配
> 操作系统可以分配k个连续的虚拟内存页面，并且将它们映射到物理内存中任意位置的k个任意的物理页面


# what I now konw?
- 虚拟内存空间（virtual memory）
  - 名义上是一个4G（32位操作系统）连续的内存空间，其地址通过页表（page table）映射到物理内存地址上
- 页表
  - 由Page Table Entry（PTE）组成的一个数组，记录着虚拟内存中地址是否有效 & 所关联的物理内存地址
  - 每个进程都有自己独立的页表
  - linux中进程信息结构体吗，task_struct中有个pgd（page global directory），指向该进程的页全局目录
- 页表条目（PTE）
  - 记录虚拟页帧映射到物理页帧的数据
  - 每个PTE包含两个部分，有效位（valid bit）和物理页帧号，有效位仅仅能代表有没有给该虚拟页关联物理页
  - 每个虚拟页帧可能属于以下的几个状态之一
    - 未分配
      - 进程还没有正式申请该虚拟地址空间，访问该地址属于是非法行为
      - PTE内容全为0
    - 已分配，未缓存
      - 进程已经申请该虚拟地址，但是还没有访问过该处内容，应用按需分配（Demand Allocation），会在第一次读写该内存时，触发缺页异常（page fault），然后切换到内核态，由OS来执行缺页处理程序
    - 已换出：
      - 该页面之前曾经被访问过，但是因为swapping机制被换出到磁盘交换区
      - 其有效位值为0，但是记录了其在磁盘上的位置
    - 已分配，已缓存：
      - 虚拟页关联着物理页，此时访问虚拟页的话，就是缓存命中
      - 进程访问虚拟内存的过程：在用户态下，由内存管理单元（Memory Management Unit）进行地址转换；但如果发生缺页异常的话，就会切换到内核态，由OS来处理
  - 总而言之，有效位只能说明能不能直接访问物理内存，有效位为0有可能是以下的集中情况
    - 未分配，非法访问
    - 未缓存（已换出）
    - 未初始化（首次访问），已申请虚拟空间，但之前从未访问过
    - 写时复制（copy on write），创建子进程后，父/子进程共用一块内存，当任一进程要写内存时，再给分配独自的物理页

- guess？进程拉起时
  - 操作系统会首先划分一部分空间给该进程，用于保存进程运行的数据？如 task_struct 和 页表
  - 同时给分配数据段、代码段、栈等基本的空间
  - 但这里会应用按需分配（Demand Allocation），
  - 
